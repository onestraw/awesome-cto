# 10x 高效码神
* 作者 antirez *
* 原文链接 http://antirez.com/news/112 *

## 定义
在编程神话中，10x程序员可以完成普通程序员十倍工作量，这里普通程序员的代表着擅长完成其工作，但没有10x程序员神奇能力的群体。 刻画“普通程序员”的另一说法：在该领域的专业程序员中，它代表的是平均编程输出。

## 观点
编程界对这种码神是否存在有两个极端的观点：反方认为不存在10x程序员，正方认为不仅存在，甚至还有100x程序员。

如果你将编程视为“线性”学科，那么很明显10x程序员看起来像是一种非理性的可能性。 一名跑步者怎么可能比另一跑步者快10倍？ 同样，一名建筑工人也不可能比另一名工人建造快10倍？ 但是，以非常特殊的方式编程是一门设计学科。 即使程序员不参与系统整体架构设计，实现过程中仍然需要子模块设计。

因此，如果程序的设计和实现不是线性能力，那么在我看来，诸如经验、编码能力、知识、对无用部分的识别之类的东西不仅是线性优势，而且它们在行为上以乘法方式协同工作创建一个程序。当然，当程序员可以同时处理程序的设计和实现时，这种现象就会发生的更多。任务越“面向目标”，潜在的10倍程序员就越会利用自己的能力，以更少的努力来达到目标。当手头的任务变得更加严格时，如果有关于使用什么工具以及如何实现事物的特定准则，那么10x程序员在更少的时间内执行大量工作的能力就会被削弱：它仍然可以利用“本地”设计可以做得更好的工作，但不能以更深刻的方式改变达到目标的路径，这可能包括甚至从项目中完全删除部分规范，因此要达到的目标看起来几乎是相同，但为达到此目的而进行的工作却大大减少了。

## 能力清单
在从事程序员工作的20年中，我观察到其他程序员作为同事在我的指导下与我一起工作，以实现给定的目标，为Redis和其他项目提供补丁。 同时，许多人告诉我，他们相信我是一个非常快速的程序员。考虑到我远非工作狂，所以我还将自己作为快速编写代码的参考。

以下是我认为对程序员工作效率影响最大的素质列表。

1. Bare编程能力：完成子任务

程序员最明显的限制或优势之一是处理实现程序一部分的子任务：函数、算法或其他。令人惊讶的是，根据我的经验，非常有效地使用基本命令式编程结构以实现某些功能的能力并不像人们想象的那样广泛。有时，在一个团队中，我观察到非常无能的(incompetent)程序员(甚至不了解简单的排序算法)，比起理论上非常称职但在实现解决方案实践中表现很差的毕业程序员能完成更多的工作。

2. 经验：模式匹配

凭经验，我的意思是针对许多重复任务的一套已经探索的解决方案。经验丰富的程序员最终知道如何处理各种子任务。这样既避免了很多设计工作，又尤其避免了设计错误，而设计错误又是简单性的最大敌人之一。

3. 重点：实际时间VS假设时间

如果不考虑时间质量，花费在编写代码上的小时数是无关紧要的。内在和外在的因素都可能导致缺乏专注。内部因素有拖延，对手头的项目缺乏兴趣（做自己不喜欢的事情不能做得很好），缺乏运动/幸福感，睡眠差或很少睡觉。外部因素包括频繁开会，没有实际办公室的工作环境，同事经常打扰等等。似乎自然而然地，试图提高专注并减少中断会对编程效率产生很小的影响。有时为了获得关注，需要采取极端措施。例如，我只是不时地阅读电子邮件，并且不回复大多数电子邮件。

4.  设计牺牲（权衡）：杀死5％得到90％

当不愿意认识到项目的非基本目标会导致大量的设计复杂性，或者很难实现另一个更重要的目标时，通常会产生复杂性，因为在基本特征和非基本特征之间存在设计张长(design tension，注：权衡折衷)。对于设计师来说，认识到设计中不容易获胜的所有部分非常重要，也就是说，努力和优势之间没有比例关系。为了最大化产出而执行的项目将完全专注于重要的方面，并且可以在合理的时间内实现。例如，当设计消息代理Disque时，我意识到，通过仅对消息进行尽力而为的排序，该项目的所有其他方面都可以得到显着改善：可用性，查询语言和客户端交互，简单性和性能。

5.简单

很明显，这意味着一切，而没有任何意义。为了了解什么是简单性，有必要检查一下通常是如何产生复杂性的。我认为，导致复杂性的两个主要驱动因素是不愿执行设计牺牲以及在设计活动中积累错误。

在设计过程中，如果你认为，每走一条错误的道路，我们与最佳解决方案的距离就会越来越远。最初的设计错误由错误的人使用，不会对同一系统进行重新设计，而是会导致设计另一个复杂的解决方案以应对最初的错误。因此，该项目在每个错误的步骤上都会变得更加复杂且效率较低。

实现简单性的方法是根据小金属“概念验证”(small metal proof of concepts)进行推理，以便可以在程序员的脑海中探索大量简单设计，从看起来最可行和最直接的东西开始进行。以后，经验和个人设计能力将使你可以改进设计并为需要解决的子设计找到明智的解决方案。

但是，每次需要复杂的解决方案时，重要的一点是要长时间思考如何避免这种复杂性，并且只有在没有找到更好的可能性的情况下，才继续朝着这个方向发展，即使考虑完全不同的替代方案。

6. 完美主义，或如何降低生产力和偏向你的设计

完美主义有两种变体：一种在程序中达到最佳可测量性能的工程文化，以及一种人格特质。 在这两种情况下，我认为这都是影响程序员快速交付项目的最大障碍之一。 完美主义和恐惧评审(怕评审时暴露缺点?)会导致设计偏见，根据心理或可测量的参数来精炼设计，而没有考虑如健壮性、简单性、及时交付能力，这会导致选择失误。

7. 知识：一些理论会有所帮助

当处理复杂的任务时，有关数据结构的知识，计算的基本限制(时间复杂度?)以及非常适合于对某些任务建模的非平凡算法都将有助于找到合适设计方案。不需要成为每一领域的超级专家，但至少要知道解决问题的多种可能的解决方案。例如，可以将设计牺牲（接受一定的错误百分比）和了解概率集基数估计量组合在一起，以避免复杂、缓慢且内存效率低的解决方案，以便对流中的唯一项进行计数。

8. 底层：理解机器

程序中的许多问题，即使在使用高级语言时，也由于对计算机将如何执行给定任务的误解而引起。这甚至可能导致需要从头开始重新设计和重新实现项目，因为所使用的工具或算法存在基本问题。C 语言的良好能力，对CPU工作原理的理解以及有关内核如何运行以及如何实现系统调用的清晰思路，可以避免出现严重的后期意外情况。

9. 调试技巧

经常出现花费大量的工作来查找BUG的事情。善于逐步获取有关BUG的状态，以便通过合理的步骤解决该问题，以及编写不太可能包含过多BUG的简单代码的态度可能对程序员的效率产生重大影响。

## 结语

看到程序员的上述素质如何对产出有10倍的影响，这对我来说并不奇怪。结合起来，它们可以实现从可行模型开始的设计的良好实现，并且可以比替代方法简单好几倍。 我喜欢将一种强调简单性的方法称为“机会编程”。基本上，在每个开发步骤中，都要选择要实现的功能集，以便以最小的工作量对程序的用户群产生最大的影响。
